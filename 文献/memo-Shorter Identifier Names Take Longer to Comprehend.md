# Shorter Identifier Names Take Longer to Comprehend
# Abstract
開発者はコードを理解することに大半の時間を費やしていますが、このプロセスでは識別子名が重要な役割を果たします。ロールを使用します。多くの識別子の命名スタイルが存在しますが、それらはしばしば 経験的な根拠に基づいており、短いか 識別子名が長いと理解が容易になる。この論文では 異なる識別子の命名スタイル（文字。略語、単語）がプログラムの理解度に影響を与えるかどうか。これらの効果は、その長さや意味論のために生じる。我々は プロのC#開発者72名で、ソースコードのスニペットの不具合を探して実験研究を行いました。使用したのは それぞれの開発者が3つの 識別子の命名スタイルのバージョンを測定し、その時間を測定しました。欠陥を見つけるのに時間がかかりました 言葉が導くことを発見しました 平均して、文字と比較して理解速度が19%速い。略語を使用していますが、速度に有意な差は見られませんでした。文字と略語の間に 私たちの研究の結果は、以下のことを示唆しています。コードの欠陥を検出するのは、コードに 文字や略語のみを使用しています。識別子名としての単語は プログラムの理解度を高めることができ、コスト削減と改善に役立ちます。ソフトウェアの品質。

# Introduction
識別子名はプログラム理解のために重要である。識別子の関連性は30年以上前から議論されており、例えば、Brooks [7]やSolowayとEhrlich [27]は、識別子がプログラム計画のキービーコンとしての役割を果たし、プログラムに関するより高度な知識を活性化し、プログラム理解を促進すると説明しています。
識別子はソースコードの主要部分を構成する。例えば、DeissenboeckとPizkaは、Eclipse 3.1.1のコードの約33%が識別子トークンであることを発見しました[14]。開発者は自分の裁量で識別子名を自由に選択することができますが、これは経験、スキル、気分によって結果が異なる可能性があります[26]。ほとんどの現代のプログラム作成言語では、識別子名は構文上の制限がほとんどなく、 実際の単語は任意に選択できる。例えば、開発者はタイピングの手間を省くために、識別子名に一文字を使用したいと思うかもしれない。選ばれた識別子名が無意味な場合、開発者はプログラムの機能を理解するのが遅くなる可能性が高く、特にコードに慣れていない場合には [27]。このよく知られた問題を緩和するために、多くのプログラミング言語のコミュニティはスタイルガイドを推進し、企業はソースコードの理解性と保守性を向上させる目的で特定の命名規則を確立しています。残念なことに、スタイルガイドや規約は表面を掻きむしっているに過ぎません。例えば、ほとんどのスタイルガイドでは、複合識別子名やその他の構造的なプロパティに特定の分離スタイルを使用することを明示的に推奨しています。しかし、特に意味的な特性については、しばしば言及されていないか、または単語の種類に限定されています(例えば、クラスは名前として名詞を持つべきである[1]など)。さらに、慣習はしばしば健全な経験的根拠を欠いている[29]。このように、識別子の命名が理解性や保守性に与える影響が実際にどれほど重要であるかは、はっきりしていません。識別子の命名の個々の側面を理解することは、プログラムの理解を最適にサポートする 特定の命名スタイルを選択するのに役立ち、その結果、生産性を向上させ、ソフトウェアの 品質を向上させ、コストを削減するのに役立ちます。
理想的には、識別子名は問題領域の概念を指定しますが、必ずしもそうである必要はありません。例えば、あるクラスがDataInfoContainerという名前であっても、ショッピングサイトの顧客を表している場合、その名前は概念（顧客のデータを含むということ）とは無関係であるため、それが実際に人の情報を持っていることを判別することが困難になります。この問題は他の著者によって対処されている。例えば、DeissenboeckとPizkaは、不正な識別子名を正しさと一貫性の次元に沿って分類した [14]。この観点から、DataInfoContainerという名前の識別子は、その名前が指定された概念人の下位名でも上位名でもないため、正しくない。DeissenboeckとPizkaの研究は、この問題を議論するための優れたメタ言語学的フレームワークを提供していますが、矛盾した識別子名や正しくない識別子名が実際に開発者にどのような影響を与えるかを実証的に評価していません。名前が理解性や保守性に与える実際の影響を実証的に評価しているのは、わずかな著者だけである。
本論文では、識別子名の長さと意味論1 がプログラムの理解度に与える影響を定量化した実験的研究について述べる。この目的のために、我々はプロのソフトウェア開発者を招き、異なる識別子名の命名規則(単一文字、略語、単語)に従ったコードの欠陥を発見してもらった。
本論文では2つの貢献をする。
- 識別子としての完全な単語が正の意味を持つことを示す実証的証拠
ソースの保守性や理解度に影響を与える
コード
- 私たちの実験とデータのレプリケーションパッケージを支援します。
他の研究者が我々の結果を確認し、拡張する

次のセクションでは、単一文字と単語の両方がプログラムの理解力にプラスの影響を与える理由を説明する。セクションIIIでは、研究仮説を導き、説明する。セクションIVでは、実験のセットアップについて述べる。第4節では実験のセットアップを説明し、第5節では結果を報告し、第6節では結果について議論する。第VII節では妥当性に対する脅威について述べる。

# 2. WORD-LENGTH AND SEMANTICS
本論文では、識別子名の2つの主要な側面、すなわち、長さと意味論に焦点を当てる。一方では、開発者はコードを簡潔にするためにコードを最適化し、短い識別子名を選ぶかもしれません。省略形も一般的で、結果として短い識別子名になってしまいます。これは、実際に概念を表す単語を使用することで実現できます（例えば、顧客はデータではなく、顧客という名前の識別子で表現するのが最適です）。単語は略語よりも長くなりますが、意味はより明確です。どちらのスタイルに最適化するかは、偶然や個人的な好みに任せるべきではなく、人間の開発者に焦点を当てた実証データに基づくべきです。
心理学的な研究では、自然言語テキストの可読性や理解度が研究されてきましたが、短い文字列と完全な単語の両方の識別子名を支持する結果が得られています。一方で、単語長効果[4]によって予測されるように、略語や文字などの非常に短い識別子名は、長い識別子名よりも、プログラムの理解の際に認知的に処理するのに必要な労力が少ない。この効果は、短い文字列のリストの方が長い文字列のリストよりも覚えやすいことを説明している。この効果は、短い文字列のリストの方が長い文字列のリストよりも覚えやすいということを意味しています。
さらに、文字列の長さはテキストの認知処理と相互作用することがわかった。長い文字列は、短い文字列よりも発音に時間がかかり [5]、命名の遅延（すなわち、遅延して発話される）が高くなります [30]。これは、任意の文字列や存在しない単語（例：「awek」、「enemenemoo」）などの非単語や、低頻度の単語（例：「penul-timate」、「hypochondriasis」）は影響を受けますが、一般的な単語（例：「awake」、「hat」）は影響を受けません。発音のしやすさを制御した研究では、発声のプロセスではなく、むしろ文字列の音声学の必要な合成が遅延の原因であることが示された [30]。
デュアルルートカスケードモデル（Dual Route Cascade Model、DRC、[12]）は、これらの知見を説明している。自然言語で一般的な単語（例：「目が覚めた」、「帽子」）は、メンタルレキシコン（すなわち、概念を読み言葉や話し言葉にマッピングする辞書）に格納されている。それらが知覚されると、それらは語彙ルートを介してアクセスすることができる（すなわち、それらは、精神的語彙から概念または意味を活性化する）。この精神的語彙に存在しない単語は、すぐにアクセスすることができない。なぜなら、その音声学はその場で合成されなければならないからである。
単語長効果（短い単語ほど覚えやすい）とは対照的に、単語優位性効果は、通常の単語がプログラム理解にプラスの影響を与えることを予測しています[23], [28]。単語優位性効果に関する心理学的研究では、単一文字が単語に埋め込まれている場合には、単語以外の文字やそれ自体とは対照的に、単一文字を検出しやすくなることが示されています。単語の存在は、同様にソースコードの処理を容易にし、ソースコードの理解を支援する可能性があります。
ソースコードを理解する際には、ワーキングメモリが重要な役割を果たします。人間のワーキングメモリは限られており3、単語の意味論は、項目をより意味のある単位に再グループ化するチャンキング[4]と呼ばれるプロセスを通じて、認知資源を再利用するのに役立ちます。例として、次のような方法を考えてみましょう。
  drawCell(a, b, c, d, e, f)
6つの浮動小数点値のパラメータを受け付けます。変数が何を表しているのかが不明で、何のために使われているのかを推測するのは困難です。このメソッドは次のようにリファクタリングすることができます。
  drawCell(x, y, size, r, g, b)
このメソッドはまだ6つの個別のパラメータを受け付けていますが、セマンティクス的には以下のように再編成しやすくなっています。
  drawCell(point, size, color)
このように、開発者は、6つのパラメータの代わりに、3つのパラメータで作業することができます。このようなコードの変更は、精神的なチャンキングプロセスに類似しており、ワーキングメモリを軽減するのに役立つかもしれません。
さらに、単語の意味論は隣接する単語がどのように処理されるかに影響を与えます。この効果は、矛盾を発見するのに役立つかもしれません。

コードが抽象的すぎると、リスト1とリスト2に示されているように、意味的な欠陥を検出するのが難しくなるかもしれません。

Listing 1: A login function using letter identifier names
```
d.u()
v(u, p): u1 = p1 =
d.p()
return u == u1 and p == u1
```

Listing 2: The same function using word identifier names
```
login(username, password):
user = db.username()
pass = db.password()
return username == user and password == user
```

識別子の名前だけが変更されました。両方のコードは構文的には有効ですが、より具体的な文脈のセマンティクスが存在するとき、矛盾は(議論の余地なく)リスト2で検知しやすくなります。リスト1は抽象的な識別子の名前だけを使うので、意味的な欠陥を検出するのは難しいです。しかしながら、リスト2のようにコードスニペットをリファクタリングすると、間違った比較が行われていることがわかります (ユーザーに対するパスワード)。このように、意味のある完全な単語の識別子名はコンテキストセマンティクスを活性化し、開発者がコードを目的に対して評価することを可能にします。
要約すると、識別子名の短さと意味論はプログラム理解への効果に関して互いに矛盾しているように見え、開発者がどちらの効果からより多くの利益を得られるかは明らかではありません。

# 3. Hypothesis
本研究では、以下の研究課題に取り組む。
識別子名の長さと意味論は、プログラム理解時の開発者のパフォーマンスにどのように影響するか？
識別子名の長さと意味論は、プログラム理解における開発者のパフォーマンスにどのように影響するのか？識別子名の意味論がプログラム理解に最も効果があるとすれば、顧客やリクエストなどの識別子名として単語を使用したコードの理解は、省略形(cusやreqなど)や文字(cやrなど)などの識別子名として単語以外のものを使用したコードよりも速くなるはずである。識別子名の長さが実際には意味論よりも理解にとって重要であるならば、短い(しかし、潜在的にはあまり意味がない)識別子名の方が、識別子名として単語を使用するコードよりもコードの理解が速くなるはずです。
しかし、長さの実際の影響を決定することは困難である。なぜなら、前述の心理学的効果から異なる予測が引き出されるからである。一方で、非単語の処理はその長さに依存する。このように、略語は一文字の場合に比べて長いため、処理にはより多くの労力を必要とし、プログラムの理解力を低下させると考えられます。一方、略語の残存する意味的特性は、より高度な認知プロセス（すなわち、語彙的処理の容易さ、意味的プライミング、チャンキング）を促進する可能性があり、したがって、略語は、識別子名としての文字を含むコードよりも高速な理解につながるはずである。しかし、単語の意味は語彙的にアクセスされることが予想されるため、略語の方が完全な単語よりも理解が遅くなるはずである。
さらに、識別子名の意味的な特性は、コードの知覚的な処理よりもプログラムの理解に影響を与えると推論した。したがって、コードを理解しようとせずにコードを操作するパフォーマンスは、完全な単語の存在によってプラスに影響されるべきではないと考えられる。しかし、このような低レベルの処理では、コードの量を減らすことで処理が速くなる可能性がある。識別子の意味が無関係な場合（例えば、セミコロンの欠落を見つけるなど）は、文字数が少ない方が読み取るコードが少ないことを意味し、そのようなタスクでの性能を向上させる可能性があります。
本研究では、この問題に答えるために、以下の仮説を評価する対照実験を計画した。

    RHWords:Non-Words。識別子名としての単語は、非単語に比べてソースコードの理解が早い。
    RHAbbreviations:Letters。識別子名としての略語は、単一の文字に比べてソースコードの理解が速くなります。
    RHSyntax. 識別子名の命名スタイルは、構文エラーの検索に影響を与えない。

## A. Independent variables
意味論と長さの関係を調べるために、文字、略語、単語の3つの条件で理解力を調べた。文字は、最小の識別名である（識別名は1文字より短くすることはできない）。単語はより多くの意味を持ちますが、長さも長くなります。略語はこの2つの妥協点を形成しています。

## B. Dependent variables
我々は、開発者がコードのスニペットを調査して欠陥を発見するまでの時間を測定することで、理解度のパフォーマンスを操作可能にした。我々は，コードが理解されて初めてコードが修正されると仮定した．開発者には、意味的な欠陥を発見したときに、理解の正確な瞬間を近似的に示すことを再度求めました。
コントロール条件として、コードの深い理解を必要としないタスクにおいて、識別子の命名スタイルがパフォーマンスに影響を与えるかどうかもテストした。これにより、我々の条件が実際に理解度に影響を与えているのか、それとも他のプロセスが測定されているのかを評価することができました。これを達成するために、開発者が構文エラーを見つけるのにどれだけの時間が必要かを測定しました。括弧やセミコロンの欠落などの構文エラーは、コードを無効にし、その識別子名の意味を深く理解して修正する必要はありません。

# 4. Study Design
私たちは、ウェブベースの実験研究で仮説を検証しました。参加者には、6つのコードのスニペットから欠陥を見つけて修正するように求めました。このタスクにどれだけの時間を費やしたかを測定しました。実験の範囲は、C#開発の文脈における参加者の理解速度に関するプログラム理解への影響を定量化する目的で、識別子の命名スタイルを分析することでした。Wohlinら[33]が提供したテンプレートに従った実験の概要を表Iに示します。

## A. Participants
プロのC#開発者72名（年齢M±SD：35.3±6.8年）を募集しました。全体的なプログラミング経験は14.0±5.8年であった。彼らのC#の経験は7.8年±3.6年であった。TwitterやXingなどのオンラインプラットフォームを利用して実験に参加してもらいました。また、ドイツのテクノロジー業界のカンファレンスの参加者にも声をかけた。
全体では221人が実験への参加を開始し、135人が実験を完了した。63人の参加者の記録は、高いデータ品質を確保するために除外基準を適用した後、削除しました（下記参照）。残りの参加者は実験シーケンスに無作為に割り当てられた。彼らの詳細を表 II に示す。
データを取得するために、プロジェクトのウェブサイトから入手可能なウェブアプリケーションを実装した。実験はオンラインで実施したため、作業環境に支障がないことを保証することはできなかった。この潜在的な妥当性への脅威を減らすために、データの妥当性に影響を及ぼす可能性のある外乱やその他の要因を管理した。例えば、参加者には、指示やコードコメントを理解するのに十分な自然言語スキルが求められ、C#の実用的な使用経験が1年以上あることが求められました。参加者は、ドイツ語と英語について、1から6までの尺度で自分の言語能力を自己評価しました。コードは英語の識別子名を使用して書かれており、指示はドイツ語で行われていたため、どちらかのカテゴリで4以下の評価を受けた参加者のデータは除外されました。プロの開発者を対象とし、学生の選択は避けましたが、最終サンプルには2人の学生の記録が残っています。彼らは、プロの開発者とみなされるために、C#の適切な経験があると述べています。すべての除外基準と影響を受けた記録の数を表IIIに示します。


## B. Task
参加者のタスクは、コードのスニペットの中から1つの欠陥を見つけることでした。タスクは6回繰り返されました。参加者は3つのスニペットで意味的な欠陥を見つけた後、さらに3つのスニペットで作業をするように求められたが、今度は構文エラーを探すように求められた。
参加者の視覚情報についての粗視化されたデータを収集するために、我々は制限焦点ビューアの実装[16]を使用した。我々の実装では、参加者がコード上で見ることができるのは一度に7行（スニペット全体の約3分の1）に制限されていたが、矢印キーを使ってフレームを上下に移動させることでコードの残りの部分を表示することができた。私たちはこの機能を「レターボックス」と呼びました。これは、ドアや郵便受けの手紙のスリットから覗き見をするのを模倣しているからです。
参加者が欠陥を見つけたら、スペースバーを押してレターボックスをフリーズさせ、ダイアログ画面を開き、欠陥の行番号、説明、修正を入力しました。参加者が欠陥を発見したことを示すまでのコードを見ていた時間を測定しました。つまり、タスクの全時間から、ダイアログに回答する時間を差し引き、参加者がコードと対話した時間だけを評価しました。このようにして、コードを理解するのに必要な時間だけを分析しました。3回の試行でスニペットの欠陥を発見できなかった参加者は実験を終了させたが、そのデータは除外された。
プログラム理解度の指標として、意味的欠陥を発見するのに要した時間を用いた。これは正しさをスコア化するのが容易であり、応答には明確に定義されたタイムポイントがあるため、反応時間の分析が可能である。さらに、意味的欠陥を発見するには、コードの背後にある意図（何をすべきか）とその動作の意味論（何をするのか）を理解していることが、正しい応答を与えるために必要である。この研究はオンラインで実施されたため、声に出して考えるプロトコルは除外しました。欠陥を見つけることは、一般的なプログラミングのタスクであり、プログラム理解度を研究するための関連するターゲットとなります。

## C. Materials
単純なアルゴリズムを含む11のコードスニペットを開発しました。参加者が見たことがないコードを確実に作成しました。スニペットは、妥当な時間枠で理解できるように十分に単純である必要がありましたが、コードの中に欠陥が「隠れる」ように十分に複雑である必要がありました。それぞれのスニペットは15行の長さの自己完結型の静的関数で構成されていました。リスト3は例を示しています。コードは、ループ、条件式、基本的な また、C#での豊富な経験による偏りを避けるために、再帰や特定のAPI(言語統合クエリ(LINQ)など)を使用しています。各スニペットには3つのバージョンがあり、識別子名は単語、略語、文字のいずれかに変更されています。例 が表IVに示されている。各スニペットは、1つのバージョンで 意味上の欠陥があるバージョンと、構文上のエラーがあるバージョンがありました。エラーの位置が異なることによる偏りを避けるために、エラーはコード内の類似した位置に配置した。
各スニペットは、最初に表現的な単語の識別子名で構築されました。このバージョンから、自動化されたプロセスで識別子名を置き換えることで、2つの派生バージョンが生成された。省略形は、識別子名から母音を削除し、最初の3つの子音をそのままにして(例えば、requestはrqsになりました)、元の単語の痕跡が残るように生成されました。単語の中には、最初の3文字で省略されるのが一般的なものもあります(例えば、長さを表すlenなど)が、代わりにこれらの省略形を使用しました。文字版では、コードの妥当性を確保するために、識別子の名前をアルファベット順に付けました。識別子が元の識別子名に似ていないことを保証するために、アルファベットで置き換えることにしました。標準の.NET APIはそのままにしておきました(例えば、ListやDictionaryのような識別子は省略されていません)。各関数は上部にコメントを付けました。最初の行には、メソッドの目的とする機能の説明が含まれています。次の行は、変数を説明し、略語と文字のバージョンでは、元の意味を示しました。
パイロット研究では、スニペットの適合性を評価しました。験者には、単語識別名を持つ3つのスニペットを見せ、参加者が意味的欠陥を発見するまでの時間を測定しました。パイロット研究のデータは、研究の質問に答えるためには使用されなかった。オンラインで2つの異なるサンプルの参加者を募集したが、サンプル間のわずかな重複を防ぐことはできなかった。学習効果を防ぐために、パイロット研究に参加した人の記録は除外した。
パイロット研究の後、5つのスニペットを削除しました。これは、測定された時間のばらつきが大きすぎる（速い参加者と遅い参加者の差が大きすぎる）か、難しすぎる（参加者全員が比較的遅かった）ためです。スニペットの分散による理解力の差を最小限に抑えるために、実際の実験では11のスニペットのうち6つのスニペットを使用しました。
リスト3、4、5は3つのスニペットのバージョンを示していますが、これらはすべて、2つのリストを連結するアルゴリズムが同じであることを示しています。欠陥は21行目にあり、その修正は次のようになります: result[index + length] = second;。

## D. Procedure
参加者は公開されているサイトに招待され、紹介文、同意形成に関連する法的情報、プライバシーステートメントが掲載されていました。そこから実験に参加し、いくつかのアンケートを実施した。彼らは、学歴、雇用状況、職業経験についての情報を提供するように求められた。その後、チュートリアルが行われ、徐々に実際の実験に慣れていった。
チュートリアルの後、次のタスクの概要が事前に送信された。次の画面では、スペースバーを押してトライアルを開始するように指示されました。参加者はコードを検査し、欠陥を探しました。欠陥を見つけたら、再びスペースバーを押し、前述の修正ダイアログを開きました。記入後、参加者は自分の答えが正しかったかどうかをフィードバックしてもらい、実験を継続する動機付けとしました。
実験終了後、最後のアンケートでは、参加者の人口統計学的データと、実験中に気が散ったことがあったかどうかを尋ねた。

E. Design
本実験の目的は、識別子の命名スタイルがプログラム理解に及ぼす影響を定量化することであった。この効果を可能な限り分離するために、理解力に影響を与える可能性のあるいくつかの要因、すなわち、参加者間の個人差の影響、スニペットの難易度、順序効果をコントロールしました。その結果、図1に示すようなデザインとなった。
1) 個人間差異。1) 個人間差異：個人間差異を制御するために、被験者内デザインを使用して、すべての参加者が異なる識別語の命名スタイルのすべての実現を見るようにしました。これにより、参加者のスキルレベルの違いを補正することができ、例えば、読むのが遅い人はすべてのタスクで遅くなるというようにした。
2）物質的影響。2) 素材の影響：素材による副作用（例えば、複雑な問題を理解するのに時間がかかるが、識別子の命名スタイルが原因ではない）を軽減するために、パイロット研究で設定した難易度（Group EasyとGroup Difficult）に応じて、スニペットをそれぞれ3つのスニペットの2つのセットにグループ分けした。最終的な実験では、半分の参加者には、まず易しいグループから意味的に欠陥のある3つのスニペットを、次に難しいグループから構文エラーを含む3つのスニペットを、残りの半分の参加者にはその逆のスニペットを見せました。さらに、スニペットの難易度と順序の効果を相殺するために、各グループ内のスニペットの順序を変えた。
3) 条件順の効果。3) 条件順序の効果：条件順序の効果（実験期間中のパーフォーマンスの増減につながる可能性がある）を軽減するために、各グループ内の識別子の命名スタイルの順序を変更した。表Vは、1人の参加者の試行の例を示しており、簡単なグループはスニペット1、2、および3で構成され、難しいグループはスニペット4、5、および6で構成されています。
これらの要因を組み合わせて順応させ、72の異なるスニペットのシーケンス(3！識別子の命名スタイル×3！スニペットの順序×2難易度の順序)を生成し、これはサンプルサイズも定義しました。
要約すると、すべての参加者が見た。
- 最初に3つの意味的欠陥があり、次に3つの構文エラーがあった。
- すべての識別子の命名スタイル
- 6つのスニペットすべて、各スニペットに一度だけ遭遇しただけ パイロット調査の間、私たちは、構文の er-が、そのようになることを観察していました。
の方が、意味的欠陥よりもはるかに早く発見された。このように、参加者がこれからの作業量に落胆して実験から脱落してしまわないように、最後の3つの項目（構文エラー）を合わせると、前の項目（意味的欠陥）と同じくらいの時間が必要であることを説明しました。全体では、実験時間は20分から30分と説明した。

# 5. Result
この仮説を検証するために、参加者の反応時間データ（すなわち、コードを見てからスペースバーを押すまでの時間）を分析した。このセクションでは、まずデータの準備と記述的統計量を提示し、次に仮説の検定を行います。
## A. データの準備と記述統計
表 VI と図 2a は、生の反応時間データの要約を、識別子の命名スタイルごとに分けて示したものである。図2aに示されているように、データは斜めになっており、速い反応が左側に蓄積され、分布の右側には遅い外れ値のテールがあるという、反応時間によく見られる現象です[22]。このような状況では、平均や標準偏差などの一般的な記述統計量は解釈が難しくなります。この場合，中心傾向の尺度としての中央値や分散の尺度としての四分位間範囲（IQR4）がより適している [31]．
外れ値の存在は、実験的分析の力を低下させる可能性があります。Ratcliff [22]によると、外れ値とは「研究対象ではないプロセスによって生成された応答時間」のことで、例えば、参加者が気を取られていたり、注意力を失っていた可能性があります。外れ値の影響を減らし、統計ツールの力を維持する方法はいくつかありますが、それには、トリミング、勝ち抜き、変換などがあります。トリミングは、あるカットオフ閾値以上の外れ値データポイントを削除し、勝ち値化はそれらを閾値に置き換え、データのトランスフォーミングはデータの分布を変更して、特定の値を優先させます[22], [19]。
我々は逆変換を使用してデータを変換することを選択しました。これは、外れ値の影響を軽減すること、データの保持、および反応時間に適用する場合の解釈可能性の間の良い妥協点を表しています[22]。逆変換された反応時間データは直感的な解釈ができるため、対数変換よりも逆変換を選択しました。
変換された値は、欠陥ごとの分数ではなく、単に1分あたりの欠陥、すなわち欠陥の発見速度を表現しています。データは表VIIに表示される。例えば、略語や文字の代わりに単語を用いてコードの意味的欠陥を発見する場合、参加者は、平均して１分当たり１９％多くの欠陥を発見し、従って、単語を識別子名として使用した場合には、より高速であった。

## B. Hypothesis Testing
意味的欠陥と構文エラーの推論統計量を別々に計算した。我々は意味課題に分析を集中させ、構文課題の分析にはより経済的な方法を用いた。すべての検定について、有意水準をα = 0.05と定義した。
1) 意味的欠陥. 1) 意味的欠陥: 線形対照を用いて、意味的欠陥に対する識別子の名前付けスタイルの効果を検定した [32]。分散分析（ANOVA）アプローチは、実験的な要因（例えば、識別子の命名スタイル）の全体的な効果があるかどうかを確立するためにオムニバスF-検定を使用しますが、効果を正確に特定することはできません[2]。線形対照は、因子レベルのグループ（例えば、単語と非単語）を互いに比較して検定することで、より具体的な仮説を検定することができます。セクションIIで説明したように、我々は、単語、略語、および文字の間の関係についての仮定を持っていたので、先験的に線形対照を定式化することができた。この検定は、重み付けされた対照変数を作成し、それをStudentのt-検定 [32]で検定する。逆変換は反応時間データに正規化効果があり、サンプルサイズが十分に大きい場合、t検定は分布の仮定からの小さな偏差に対してロバストであるため、正規性からの偏差は本分析では問題になりません。
我々は、文字と略語をグループ化して対照比較（ΨWords:Non-Words）を行い、単語と非単語を比較しました。次に、文字と略語および省略語をグループ化して、文字と省略語を比較しました（ΨLetters:Abbreviations）。我々の統計的仮説に沿って、我々は検定を行った。

```
ごにょごにょ
```

With Performance : 理解力速度を1/RTで表したもので、数値が大きいほど理解力が高いことを示しています。
単語と非単語の理解速度の間には、統計的に有意な差が見られた(tΨWords:Non-Words(71) = 2.73; p = .004)。文字と略語の間には有意差はなかった（tΨLetters:Abbreviations(71) = 0.07; n.s. 単語と非単語の差は、小～中程度の効果を示した（dz = 0.32、[10]）。その効果を図2bに示す。
2) 構文エラー 2) 構文エラー：識別子の命名スタイルは構文エラーの検索に影響を与えないと考えていたため、効果の対照を指定するのではな く、より経済的なオムニバスANOVA法を使用した。図2cに示されているように、構文エラーの検出に識別子の命名スタイルが有意な効果を見出すことはできなかった(F (2, 142) = 0.8; n.s.)。我々の研究では、η2 = 0.04という小さな効果の大きさを検出するために80%の統計的な力を持っていることを考えると、この結果は、識別子名が構文エラーの検出にはせいぜい無視できる程度の効果しかないという仮定を支持していると解釈します。

## C. Visual Attention
さらに、レターボックスで得られた視覚的注意データを分析した。識別子の命名スタイルは、参加者がスニペットの冒頭のコメントを読む（および再読する）のに費やした時間に影響を与えた（表VII参照）。 ```(FSem(2, 142) = 5.35; p = .006; η2 = 0.07; FSyn(2, 142) = 3.60; p = .03; η2 Syn⟨Style⟩ = 0.05).```これは、意味課題と構文課題に等しく影響を与えた。

# 6. Discussion
結果を要約すると、我々のデータは、提示されたコードが通常の単語を識別子名として使用した場合、単語以外のもの（略語や文字）と比較して、参加者が意味的欠陥を発見するのが有意に速くなったことを示している。識別子名として略語や文字を使用したコードの場合、参加者は同じように速くなりました。識別子名の付け方は、構文エラーの発見に影響を与えないようである。これらの結果から、プログラムの理解度は明示的な識別子名が有利であることが示されました。
単語の長さ効果は、短い文字列の方が覚えやすいことを予測していますが、文字や略語は理解力の向上にはつながりませんでした。その代わり、単語を識別名として使用した場合、意味的欠陥がより早く発見されるため、単語の長さが長い方が理解を容易にしているように思われた。さらに、意味的課題と構文的課題を比較すると、意味的判断を必要としない課題であっても、識別子名の長さなどの純粋な知覚的特性だけでは、パフォーマンスの違いを説明するには不十分であることが示された。しかし、この場合、単語の識別子の意味的内容も利点ではない。理解力の差が生じたのは、単語の意味的内容が、チャンキングや意味的プライミングなどの開発者のコグニティブなプロセスを容易にし、一般的にワーキングメモリを緩和することに起因している可能性が高い。このことは、単語の条件では、参加者が変数の意味を検索するためにソースコードのコメントまでスクロールする頻度が低かったという事実によっても裏付けられています。
言い換えれば、単語の識別子名は、開発者が識別子によって表される概念の意味に直接アクセスすることを可能にし、それによってコードについてより容易に推論することができるかもしれません。しかし、これらのプロセスの正確な性質を区別するためには、さらなる実験が必要である。
これらの結果を考えると、非単語を支持する議論には疑問が残る。例えば、コードが書かれるよりも読まれることの方が多いことを考えると、長い単語のタイピング努力が増えるという欠点は、意味論が増えるという利点に勝るものではありません。実際には、適切なツールを使えば、この欠点は軽減される可能性があります。例えば、最新の IDE は自動補完機能を提供しており、すでにタイピングの労力を軽減しています。今後の研究では、最新のIDEにおけるタイピングの労力と理解度の関係を定量化することが興味深い。
要約すると、我々のデータは、識別子名として単語を使用することで、ソースコードの理解度と保守性が向上することを示している。このように、我々は開発者がこの慣習に従うべきであるという証拠を提供しています。なぜならば、それは理解しやすく、保守性の高いコードになる可能性が高く、コードの品質にも影響を与えるからです。

# 7. THREATS TO VALIDITY
## A. 内部妥当性
これはサンプリングバイアスと解釈される可能性がありますが、実際には、迷惑要因（言語の壁、気晴らしなど）の影響を減らすことでデータの質を向上させるために適用された厳格なフィルタリングルールの結果でした。

## B. 構成要素の妥当性
もう一つの脅威は、プログラム理解を「欠陥を発見する時間」として運用化することである。欠陥発見までの時間は、プログラム理解を単独で行う場合と比較して、一定のオーバーヘッドがあり、プログラム理解のパフォーマンスを完全に測定するものではない可能性があります。しかし、これら2つの構成要素の間には大きなオーバーラップがあると予想されます。例えば、何かが「車である」ということを識別することは、それが起動しない理由を識別するよりもおそらく簡単な作業ですが、前者のプロセスは後者のプロセスを可能にするために必要です。同様に、コードスニペットが配列をソートしていることを特定することは、アルゴリズムの複雑さや、欠陥のあるコーナーケースが含まれているかどうかを調べることとは別の作業です。

## C. 外部妥当性
我々のサンプリング基準は、非常に特定の集団、すなわちドイツのプロのC#開発者に限定しました。したがって、我々の知見が過度に一般化されるべきではありません。最初の生データで女性と確認された参加者は2人だけでしたが、除外基準を適用した後、彼らの記録は最終的なデータセットには含まれていませんでした。しかし、プログラム理解は複雑な思考活動であり、専門的な教育と経験が潜在的な性差を上回ることを期待している。
我々の刺激資料は手続き的なアルゴリズミック問題に限定されていたため、AbstractSingletonProxyFactoryBeanのような識別子を単一化できる複雑なオブジェクト指向環境における識別子の命名スタイルの影響についての結論を導き出すことはできませんでした。これらの非常に長い識別子名は、明示的であろうとしていますが、プログラム理解を容易にするために意味のある意味論を提供するには抽象的すぎるかもしれず、プログラム理解のパフォーマンスを阻害することになります。また、ここでは単語長効果がより強い役割を果たしているかもしれません。しかし、この結論は次の実験で検証する必要がある。
我々の研究では、コードのどこかに意味的な欠陥があるかどうかを検索するように参加者に指示した。このような指示は、欠陥に関する知識、検索戦略、注意の方向性など、コード理解のための追加的な資源を活性化した可能性があります。通常の状況では、このようなプライミングは必ずしも起こらず、開発者はコードに問題があるかどうかを識別する必要があるかもしれませんし、このようなヒントなしでコードを理解することはより退屈なプロセスである可能性があります。このように、我々の指示は、そうでなければ理解プロセスに影響を与えない追加のリソースを活性化させ、識別子の命名スタイルの影響の大きさを小さくすることで、我々のパフォーマンス測定に影響を与えた可能性があります。このように、本研究では、「意味論的に豊かな識別子名としての単語」が、追加の指示がなければ、より価値のあるものになるかもしれない。
実験のセットアップでは、開発者の日常業務に関連したタスク（意味的欠陥の発見）を選択しましたが、参加者にリーチするために、これらのタスクは実際のIDEではなくオンラインで実行されたため、人為的なものとみなされる可能性があります。我々のウェブアプリケーションは、フォーカスを制限したビューアによって理解力が低下した可能性があり、通常の環境では理解力は速くなるはずである。この障害はすべての実験条件においてすべての参加者に存在していたので、応答時間を正常化し、識別子の命名スタイルの効果を強調し、結果としてツールの性能を向上させた可能性があります。最後に、現代の複雑なコードベースは数百万行のコードを持つ可能性があることに留意すべきである。観測された効果の大きさ dz = 0.32は，15行のコードで観測された小～中規模の効果を示している。識別子の命名スタイルの効果は，大規模なプログラムではさらに顕著になると思われる。参加者は、15行のコードを単語の識別子名で処理するのが平均で19%速くなり、これは、より多くのコードを調査しなければならないときに、コードを理解するのに必要な時間、あるいは数週間を節約できる可能性があります。しかし、この効果を確実に予測することは困難です。より大きなコードベースの一般的な略語はすぐに記憶され、開発者はプログラム理解の間にペナルティを受けない可能性があります。例えば、for-loop でインデックスとして i という文字を使用することは、慣用的であると考えることができます。同様の効果は、企業のドメイン固有の識別子名にも見られるかもしれません。
我々は多くの要因をコントロールしたが、この効果を完全に理解するためにはさらなる研究が必要である。理想的には、実験室で研究を行うか、他のプログラミング言語で書かれた刺激資料を用いて研究を行うことで、この効果を分離することができます。


# 8. 関連する作業
Lawrieらは、参加者が文字、略語、および単語を用いてコードを読むという同様の実験を行った[17]。彼らは、略語を用いた識別名に対する反応は、通常の単語に対する反応と類似性を示したが、我々の実験では、文字に対する反応の方が類似していた。しかし、我々の実験結果は、識別名としての単語の方が文字よりも理解度が高いという点で、彼らの実験結果と一致している。この違いは、略語の構築に用いられた戦略に起因していると考えられる。Lawrieらは、単一の単語よりも長い複合識別子名を省略している(例えば、isPrimeNumberをisPriNumにするなど)。このような省略形は、我々の研究で使用された識別子と比較して、元の識別子名との類似性をより多く保持している。したがって、それらの結果は我々の研究と一致しており、我々の仮説の延長線上にあると理解できる。
その後の論文では、Lawrieらは、識別子名の長さがワーキングメモリと相互作用して、単語や略語が単一の文字よりも認識課題で識別しやすくなることを示しています[18]。これもまた、彼らの研究ではより長い略語に当てはまる。これらの結果から、意味論がソースコードの理解に関連しており、理解能力の違いを純粋に知覚的に説明するだけでは不十分であることが、私たちの結果をさらに裏付けるものとなりました。
Epelboim [15]は識別子の分離スタイルに関する研究を行っていますが、これはBinkleyら[6]や、Binkleyら[6]の研究を再現したSharifとMaletic[25]によっても取り上げられています。これらの研究はすべて、識別子名のアンダースコアがキャメルケースに比べてプログラムの理解を容易にすることに同意しています。SharifとMaletic [25]は、この点でスタイルへの親しみやすさの影響を強調しており、 初心者はエキスパートよりもアンダースコアの方が恩恵を受けることを示しています。識別子名の構文的特性は知覚的プロセスを促進するが、意味的特性は高次の認知的プロセスを促進する。人々が最適に理解できるコードを書くためには、両方の側面を考慮すべきである。
さらに、SharifとMaletic、Bink-leyらの研究では、参加者が以前の経験と一致するコードを提示されたときに、より良い理解が得られることがわかりました。Binkley らの研究では、キャメルケースの経験のある参加者は、アンダースコアの識別子に比べて、キャメルケースの識別子を識別するのに時間がかからないことが示されています。SharifとMaleticは、これらの結果と自分たちの結果を一致させて、「経験（トレーニング）を積むと、識別スタイルのパフォーマンスへの影響は減少するが、排除されるわけではない」と結論づけています[25]。このように、経験は、プログラム理解の関連因子を決定する際に役割を果たしているようです。我々のデータも同様の特徴を示しています。観察された効果（識別子の命名スタイルの影響）は、反応時間データの分布の中央と末尾に存在することがわかりました。このことは、エキスパート(すなわち、我々のサンプルの中で最速の開発者)は、平均的な性能を持つ開発者よりも短い識別子名や省略された識別子名の影響を受けにくいことを示しています。
Ceccatoら[9]は、意図的にコードを理解しにくくする様々なコード難読化技術を分析しました。彼らは、識別子の名前を単一の文字に変更することは、プログラムの理解を妨げる効果的な難読化技術であることを示しましたが、不可能にはならないことを示しました。これらの結果は、単語が使われている場合はコードの理解が容易になり、文字が存在している場合はコードの理解が妨げられるため、良い識別子の命名スタイルの重要性を強調しています。
Scalabrinoらは、識別子名の一貫性や狭さなどの意味的な側面を含むソースコードの「テキスト」特性を使用することで、行の長さや識別子の数、括弧の数などの構造的な側面を使用する以上に、可読性の予測が改善されることを発見しました[24]。Scalabrinoの研究や他のコード可読性の研究（例：[8]、[21]）では、可読性はしばしば、スニペットが読めるかどうかの参加者の主観的な判断として運用されます。このような主観的な評価とは対照的に、我々の実験では、行動的なパフォーマンスの指標として応答時間を採用しました。理想的には、主観的な可読性の測定と客観的な可読性の測定では、収束する結果が得られますが、この関係については、どちらかの構成要素の有効性を明確に定義するために、さらに調査を行う必要があります。

# 9 Conclusion
メンテナンスとプログラム理解がソフトウェア開発において重要な役割を果たしていることを考えると（実際にコードを入力するよりも多くのことが考えられます）、明示的なフルワード識別子を使用することが望ましいように思われます。我々の結果は、略語や
文字はプログラムの理解力を低下させ、その存在はコードの質が低いことの指標となるかもしれない。
識別子名の単語の意味的特性は、理解を容易にする認知プロセスを可能にするからです。開発者は、明示的な識別子名を使用することで、これらの認知プロセスをサポートするようにコードを最適化すべきです。
理解を可能な限り容易にするために、スタイルガイドの適切なルールは、知覚的特性と意味的特性を考慮し、略語や文字の使用を控え、明示的で明確な識別子名の使用を奨励すべきである-ソフトウェアの品質を向上させ、その開発と保守のコストを削減したいと考えている-。
将来的には、アイトラッカーを用いてこの研究を再現し、参加者の眼球運動に関するより多くのデータを得ることを計画しています。さらに、異なる集団からの参加者を募集することも計画しています。具体的には、プログラミングを始めたばかりのプログラマーを対象に、実装された概念を表す言葉がプログラム理解に与える影響を理解するための共同研究を行う予定である。一般的に、異なる文脈でのロバスト性を評価するために、ここで提示した結果の複製を歓迎する。この目的のために、本プロジェクトのウェブサイトに必要な資料をまとめたレプリケーショ ンパッケージを用意している（脚注2参照）。