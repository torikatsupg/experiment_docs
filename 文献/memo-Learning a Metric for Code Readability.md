この論文では、コードの可読性の概念を探求し、ソフトウェア品質との関係を調査します。120人の人間のアノテータから収集したデータを用いて、単純なコードの局所的な特徴のセットと人間の可読性の概念との間の関連性を導き出します。これらの特徴を使用して、自動化された可読性測定値を構築し、可読性の判断を予測する際に80%の効果があり、人間よりも平均的に優れていることを示しました。さらに、この指標は、コード変更、自動化された欠陥レポート、欠陥ログメッセージというソフトウェア品質の3つの指標と強い相関関係があることを示しています。これらの相関関係は、220万行以上のコードと、選択されたプロジェクトの多くのリリースにわたって、縦方向に測定しました。最後に、この研究がプログラミング言語の設計とエンジニアリングの実践に与える影響について議論します。例えば、我々のデータは、コメントはそれ自体が単純な空白行よりも、ローカルな可読性の判断にとって重要ではないことを示唆しています。

# 1
可読性とは、文章がどれだけわかりやすいかを人間が判断したものと定義しています。プログラムの可読性は保守性と関連しており、ソフトウェア全体の品質を左右する重要な要素です。一般的に、メンテナンスはソフトウェア製品の総ライフサイクルコストの70%以上を消費します[4]。Aggarwal氏は、ソースコードの可読性とドキュメントの可読性の両方が、プロジェクトの保守性にとって非常に重要であると主張しています。他の研究者は、コードを読むという行為が、すべてのメンテナンス活動の中で最も時間のかかる要素であることを指摘しています[8], [33], [35]。実際、可読性は非常に重要であり、ElshoffとMarcottyは、多くの商用プログラムが必要以上に読みにくいことを認識した後、プログラムをより読みやすくするための開発フェーズを追加することを提案しました[10]。KnightとMyersは、ソフトウェアー検査の1つの段階として、コードの保守性、移植性、再利用性を確保するために、ソースコードの可読性をチェックすることを提案しています[22]。Haneefは、「可読性に関する確立された一貫したガイドラインがなければ、個々のリビューアはあまり役に立たないかもしれない」と観察し、開発チームに可読性と文書化の専門グループを追加することを提案しました[16]。
我々は、プログラマはこの概念についてある程度の直観的な概念を持っており、インデント(例えば、Python [40]のような)、識別子名の選択[34]、コメントなどのプログラム機能がその一端を担っている可能性が高いと仮定している。例えば、ダイクストラは、プログラムの可読性はシーケンシング制御のシンプルさに大きく依存すると主張し（例えば、彼は、gotoが不必要にプログラムの理解を複雑にすると推測しています）、システム設計に対する彼のトップダウンアプローチの動機付けにこの概念を採用しました[9]。

我々は、プログラムから自動で抽出できる単純な特徴に基づいたソフトウェアの可読性の記述モデルを提示します。このソフトウェア可読性のモデルは、人間のアノテータや、欠陥検出器やソフトウェア変更などのソフトウェア品質の外部（広く利用可能な）概念と強く相関しています。

ソフトウェア可読性の経験的かつ客観的なモデルがなぜ有用なのかを理解するために、自然言語における可読性メトリクスの使用を考えてみましょう。Flesch-Kincaid Grade Level [11]、Gunning-Fog Index [15]、SMOG Index [28]、Automated Readability Index [21] は、通常のテキストの可読性メトリクスのほんの一例です。これらの指標はすべて、単語あたりの平均音節数や平均文の長さなどの単純な要因に基づいています。この単純さにもかかわらず、それぞれが実際には非常に有用であることが示されています。50年以上にわたって使用されているFlesch-Kincaidは、Microsoft Wordを含む一般的なテキストエディタに統合されているだけでなく、米国政府の標準となっています。国防総省を含む各省庁は、社内外の多くの文書やフォームに、フレッシュの可読性等級が10以下であることを要求しています（DOD MIL-M-38784B）。
また、国防総省の請負業者は、技術マニュアルを書く際に、それを使用することを要求されることが多い。

これらのメトリクスは、組織が文書が可読性の目標を非常に安価に達成しているというある程度の確信を得るのに役立ちます。
私たちは、特にソースコードを対象とし、有効性についての経験的な証拠に裏付けられた同様のメトリクスが、ソフトウェアの領域でも同様の目的を果たすことができると信じています。コンピュータ生成数学 [26]、ツリーマップ・レイアウト [3]、ハイパーテキスト [17] などのニッチ分野の可読性メトリクスが有用であることがわかっています。ここでは、ソースコードに対する最初の一般的な可読性メトリクスについて説明します。

可読性は複雑さと同じではないことに注意することが重要ですが、既存のメトリクスの中には経験的に有用であることが示されているものもあります[41]。ブルックスは、複雑さはソフトウェアの「本質的な」特性であると主張しています。ブルックスのモデルでは、可読性は確率文によって決定されないため、「偶発的」です。原則として、ソフトウェアエンジニアは偶発的な困難を制御することしかできません：可読性は本質的な複雑さよりも簡単に対処できることを暗示しています。
ソフトウェアの複雑さの指標は、一般的にクラスやメソッドのサイズ、およびそれらの相互作用の程度を考慮に入れますが、コードの可読性は、主に局所的な、行ごとの要素に基づいています。 一方、複雑さの要因は、人間がコードを理解できるようにするものとはほとんど関係がないかもしれません。以前の研究[31]では、人為的なコードの複雑さの指標を欠陥に直接関連付けることは困難ですが、不可能ではないことが示されています。どちらもインデントなどの局所的な要因が関係していますが、可読性はコーディング標準（例：[2]、[6]、[38]）とは異なるもので、異なる開発者によって書かれたコード間の統一性を維持することでコラボレーションを促進することを主な目的とした規約です。
本研究では、可読性は独立して価値のある概念であることと、開発者がそれを大きくコントロールできるという理由から、直接的に対象とすることにしました。第5節では、可読性と品質の間には実際に有意な相関関係があることを示します。

本論文の主な貢献は以下の通りです。
- 局所的なコードフィーアに基づいた自動ソフトウェア可読性メトリックの構築手法。
- この論文で発表され、評価されたメトリックの基礎となる100のコードスニペットに対する120人の人間のアノテータの調査。同程度の規模（12,000回の人間による判定）のソフトウェア可読性に関する研究を公表した例はありません。我々は、このデータセットで我々のモデルの性能を直接評価しています。
- このデータセットでは、我々の可読性の指標と、欠陥密度を含むソフトウェア品質の外部概念との間に有意な相関関係があることを明らかにした一連の実験が行われています。
- 我々のメトリックに関係する特徴と、ソフトウェア工学およびプログラミング言語設計との関係についての議論。
これらの主要なポイントのいくつかは、以前に発表されています[5]。この記事には、以下の内容も含まれています。
- この記事では、我々の可読性メトリクスとソフトウェア品質の概念をリンクさせた海賊実験のためのより広範なベンチマークプログラムを掲載しています。特に、これまでの研究では100万行以上のコードを評価していましたが、本稿では200万行以上のコードを評価しています。
- また、前回の発表では1つの相関統計量であったのに対し、今回は5つの相関統計量での分析結果を報告しています。
- 我々の可読性を相関させた追加の実験。
ソフトウェアの品質と欠陥密度のより自然な概念である、バグ修復に関する人間の明示的な言及を用いて、品質を測定します。ソフトウェアのバージョン管理のレポ情報を用いて、バグに対処するために行われた変更を他の変更と粗く分けています。その結果、可読性の低さは、静的解析ツールで報告された潜在的なバグを使用するという従来のアプローチよりも、この直接的な欠陥密度の概念と強く相関していることがわかりました。
- さらに、可読性とサイクロマチック複雑度を比較する実験を行いました。この実験は、我々の考える可読性という概念が、従来のコード複雑度の尺度から大きく独立しているという我々の主張を検証するのに役立ちます。
- さらに、プログラムの進化に伴い、可読性の変化が欠陥密度の変化とどのように相関するかを示す縦断的な実験を行いました。5つのプログラムそれぞれの10のバージョンについて、可読性が変化しないプロジェクトでは欠陥密度も同様に変化しないことがわかりましたが、可読性が急激に低下したプロジェクトでは、それに対応して欠陥密度が上昇することがわかりました。

自動化された可読性指標には、いくつかの用途が考えられます。スコアが低いコードを素早く特定することで、開発者がより読みやすいソフトウェアを書くのに役立つかもしれません。可読性の監視と維持において、プロジェクトマネージャを支援することができます。受け入れのための要件としての役割を果たすことができます。また、プログラムの改善が必要とされる可能性のある部分を対象とした努力を支援することで、検査を支援することもできます。最後に、警告をランク付けしたり、可読性が低くバグが含まれている可能性が高いコードのセクションに開発者の注意を集中させるために、他の静的分析でも使用することができます。この論文で紹介した可読性の指標は、静的仕様マイニングツール[24]を支援するためにすでに成功裏に使用されています。その設定では、コードパスが可読か否かを知ることは、コードパスが実行可能か否かを知ることに比べて2倍以上の予測力（ANOVAのFスコアで測定）を持ちました。
本論文の構成は以下の通りである。第2節では、120人の注釈者を対象とした可読性の研究を紹介する。第3節ではその結果を発表し、第4節では、大多数のアノテータにとっての可読性の概念を捉えるのに十分な小さな特徴量のセットを決定する。このように、本稿では、このような「可読性」の指標と、ソフトウェア品質の外部概念との間の相関関係について議論します。この作業がプログラミング言語設計に与える影響のいくつかを第6節で議論し、妥当性に対する潜在的な脅威を第7節で議論し、拡張の可能性を第8節で議論し、最後に第9節で締めくくります。

# 2
可読性は、コード品質の本質的な低下特性であるというコンセンサスは存在しますが [1], [4], [8], [9], [10], [16], [31], [32], [33], [34], [35], [41]、どの要因がソフトウェアの可読性の人間の概念に最も寄与しているかについては、そうではありませんでした。Tennyによる以前の研究では、プログラムのいくつかのバージョンの理解度をテストすることで可読性を調べました[39]。しかし、このような実験では、正確な特徴を抽出するには十分に細かい粒度ではありません。この研究では、コードサンプルが大規模であったため、知覚される可読性は、コードの目的を含む多くの特徴の複雑な相互作用から生じていました。これとは対照的に、我々は小さな（平均7.7行）コード選択のソフトウェアの可読性を測定することにしました。多くの短いコード選択を使用することで、どの特徴が可読性を最も予測するかを分離する能力が高まります。ここでは、人間のアノテータのグループから短いコードサンプルを対象に、多数の可読性判定を抽出するように設計された実験について説明します。
形式的には、ソフトウェアの可読性をコードサンプルから有限スコア領域へのマッピングとして特徴付けることができます。この実験では、スニペットと呼ばれる一連の短いコードの選択を、ウェブインタフェースを通じて人間の注釈者に提示しました。この実験では、このようにして得られた情報をもとに、各スニペットの読みやすさを個別に評価してもらいました。ここでは、スニペットの選択方針（2.1節）、スニペットのスコアリング（2.2節）、参加（2.3節）という3つの重要なパラメータについて議論します。

## 2.1 Snippet Selection Policy
私たちは、コードの可読性は自然言語とは大きく異なると主張しています。コードは高度に構造化されており、設計、文書化、ロジックなど、さまざまな目的を果たす要素で構成されています。このような問題から、スニペットの選択が重要な課題となっています。我々は、Javaプログラムからスニペットを抽出する自動化されたポリシーベースのツールを設計した。
まず、特徴の識別を助けるために、スニペットは比較的短いものでなければなりません。しかし、スニペットが短すぎると、重要な可読性の考慮事項が不明瞭になってしまう可能性があります。第二に、スニペットは論理的に一貫していなければならず、アノテータがその読みやすさを理解するためのコンテキストを提供することができます。我々は、スニペットは複数のメソッド本体にまたがってはならず、スニペット内のコードを文書化する隣接コメントを含むべきであると主張しています。最後に、"trivial "なスニペットの生成は避けたいと考えています。たとえば、インポート状態をすべてボイラプレートで構成したスニペットや、コメントで構成したスニペットの可読性を評価することには関心がありません。
その結果、スニペットは人間による分析を十分にサポートするために可能な限り短くなければなりませんが、人間が重要な判断を下すのに十分な長さでなければならないという重要なトレードオフが存在します。文脈が理解に重要な場合がある読解プロセスを「シミュレート」することが我々の意図ではないことに注意してください。それどころか、文脈や複雑さを大幅に排除し、代わりに読みやすさの「低レベル」の詳細に焦点を当てることを意図しています。コンテキストが重要ではないという意味ではなく、それ自体が可読性、ひいてはソフトウェアの品質に強い影響を与える局所的な特徴のセットが存在することを示すことを意味しています。
これらを考慮して、Javaプログラムのスニペットを以下のように制限します。スニペットは、Javaプログラムの最も基本的な単位である、3つの連続した単純な文[14]から構成される。単純な文には、フィールド宣言、代入、関数呼び出し、ブレーク、継続、スロー、リターンが含まれる。このような命令が少ないスニペットは、読みやすさを評価するのには短すぎることがありますが、一般的には3つの文は、局所的な特徴の大規模なセットをカバーするのに十分であり、詳細な特徴に基づいた分析には十分であることが、経験上わかっています。
スニペットには、コメント、関数ヘッダ、空行、if-else、try-catch、while、switch、forのような複合状態のヘッダなど、単純な文ではない先行行や中間行が含まれます。さらに、スニペットがスコープの境界を越えることは許可していません。つまり、スニペットは複数のメソッドにまたがったり、複合文の内部で開始してその外部に拡張したりすることはありません (ただし、複合文の外部で開始しても、その文が完了する前に終了することは許可しています)。この一連のポリシーにより、我々が検討した全てのプログラム(セクション5参照)の90%以上のステートメントが、何らかのスニペットに組み込まれる候補であることがわかりました。候補にならない少数の行は、通常、3つのステートメントよりも少ない関数に見られます。このスニペットの定義はJavaに特有のものですが，CやC++のような類似言語にも拡張できます．この研究のために生成された100個のスニペットのサイズ分布（文字数）は、ほぼ正規であるが、正のスキューがあることがわかりました（平均値278.94、中央値260、最小値92、最大値577）。
スニペットは5つのオープンソースプロジェクトから生成されました（図10参照）。これらのプロジェクトは、モデルを汎用的かつ広く適用可能なものにするために、成熟度のレベルや複数のアプリケーションを含むように選択されました。我々は、セクション8でドメイン固有のモデルの可能性について議論します。

# 2.2 Readability Scoring
参加する前に、ボランティアの人間のノーテーターには、Javaコードの可読性を評価するよう求められ、参加することでソフトウェアの品質の側面に関する研究に役立つことを伝えました。回答は、ユーザーが自由にアクセスできるWebベースの注釈ツール（図1）を使用して収集されました。参加者には、1～5のラベルが付けられた一連のスニペットとボタンが提示されました[25]。各参加者には、同じ順番で100個のスニペットの同じセットが表示されました。参加者は、「より読みやすい」スニペットには5に近い数字を、「より読みにくい」スニペットには1に近い数字を選択し、3のスコアが中立を示すようにすることをグラフィカルに思い出されました。さらに、現在のスニペットをスキップするオプションがありましたが、これは非常に頻繁に使用されるものではありませんでした。(12,000回で15回)。
スニペットはソースから変更されていませんが、コードが一般的に見られる方法をよりよくシミュレートするために構文が強調されています。最後に
また、「可読性とは、コードのブロックがどれだけ理解しやすいかを判断することである」と、「可読性の評価に基づいて」スニペットに点数をつけるべきであることをリマインドしています。可読性は、参加者の誘導されていない直感的な概念を捉えるために、意図的に形式的に未定義のままにしていました。

## 2.3 Study Participation
この研究は、バージニア大学のいくつかのコンピュータサイエンスのコースで宣伝されました。このように、参加者はコードを読んだり書いたりする経験が様々でした。1年生のコースを受講していた人は17人、2年生のコースを受講していた人は63人、3、4年生のコースを受講していた人は30人、大学院生は10人でした。合計120名の学生が参加しました。調査は2008年10月23日から11月2日まで行われました。参加者には、回答者全員に5ドルが支払われるが、最も早く調査を開始した（終了しなかった）50人には10ドルが支払われると伝えられた。終了時刻ではなく開始時刻を使用することで、活動自体に時間的なプレッシャーをかけずに参加を促しました（例えば、急いで読みやすさの判断をするインセンティブはありません）。収集したデータはすべて匿名で慎重に管理され、参加者はこの事実を認識していました：アンケートに回答すると、ランダムに生成されたコードが得られ、それは金銭と交換することができました。セクション4.2では、経験が読みやすさの判断に与える影響について議論します。第7節では、実験の妥当性に対する参加者プールの影響について議論する。

# 3 Result of Study
120人のアノテータがそれぞれ100のスニペットを合計100点ずつ採点しました。
12,000 個の異なる判定の 図2は、グラフ この公開されているデータの物理的な表現。表現は、この公開データの スコアの分布は図3に示されている。
まず、アノテータ間の一致を検討し、このデータセットから単一の首尾一貫したモデルを抽出できるかどうかを評価します。同意度を測定する目的で、いくつかの相関統計量を検討します。1つの可能性としては、Cohenのκが挙げられます。しかし、我々の判断データが順序的なものであること（すなわち、カテゴリ間に質的な関係があり、カテゴリ間に全体的な順序があること）は、統計的に重要な考慮事項です。注釈者はスニペットの採点方法について正確な指導を受けていないので、絶対的な採点差は相対的な採点差ほど重要ではありません。もし2人のアノテータが両方ともスニペットXをスニペットYよりも高いスコアを与えた場合、実際のスコアの数値が異なっていたとしても、その2つのスニペットに関しては一致していると考えられます。このように、本研究ではκの線形加重版をテストしました（概念的には「近い」ランキングにはある程度の信用を与えます）。さらに、Kendallのτ（すなわち、1つのリストを2番目のリストと同じように並べるためのバブルソート操作の数）、Pearsonのρ（線形依存性の度合いを測定）、およびSpearmanのρ（任意の単調関数との依存性の度合いで、Pearsonのρと密接に関連している）[37]を考慮しました。これらの統計量について、1の相関は完全な相関を示し、0は相関がないことを示します（すなわち、一致のランダムなインスタンスのみを持つ一様にランダムなスコアリング）。ピアソンの場合、例えば、2人のアノテータがスニペットの半分を全く同じように採点し、残りの半分をランダムに採点した場合、0.5の相関が発生します。
私たちは大集合の判断を組み合わせて を平均化するだけで、単一のモデルを作成することができます。なぜなら、それぞれの相関統計は、一度に2人のアノテータの判断を比較しているからです。これを拡張して、統一モデルと各アノテータ間の平均相関を求めることで、結果を図4に表にしました。κと加重κの場合、離散値が予想されるため、スコアのモードを使用しています。この種の統計量を質的な用語に変換するのは難しいですが、0.5 以上の相関（ピアソン/スピアマン）は、人間に関連した研究では一般的に中程度から強いと考えられています[13]。我々は、その後の実験と分析でこの統一モデルを使用しています。スピアマンのρは最も一般的であり、最大の一致度をモデル化しているように見えるため、本研究では一致度の主要な尺度としてスピアマンのρを採用しています。図5は、一致の範囲を示しています。
この分析は、読めるコードがどのようなものであるかについて、人間は有意に同意しているが、圧倒的な範囲ではないという、広く信じられている信念を確認しているようです。一つの示唆は、コードの可読性に影響を与える根本的な要因が実際に存在するということです。平均スコアをモデル化することで、これらの一般的な要因のほとんどを捉えることができますが、同時に個人的な好みに大きく起因する要因は除外することができます。

# 4 Readability of code
スニペットの相対的な可読性については、我々のグループのアノテータ間で有意な一致があることが示された。しかし、この相関関係の根底にあるプロセスは明らかではありません。このセクションでは、人間の可読性判断を機械的に予測できる範囲を探ります。どのコードの特徴が可読性を予測するかを決定し、他のコードを分析するためのモデル（自動化されたソフトウェア可読性指標）を構築することに努めています。

## 4.1 Model Generation
まず、スニペットや他のコードブロックから静的に検出できる特徴のセットを作成します。比較的単純で、直感的に可読性に何らかの影響を与えそうな特徴を選びました。それらは、構造、密度、論理的複雑さ、文書化などに関連する要因です。重要なことは、セクション2.1で説明した可読性の概念と一致するように、各機能はコードブロックのサイズに依存しません。図 6 は、コードの可読性を判断する際に我々のメトリックが考慮するコード特徴のセットを列挙したものです。各特徴は、Javaソース・コードの任意のサイズのブロックに適用することができ、各特徴は、1行あたりの平均値、または全行の最大値のいずれかを表しています。例えば、各行に含まれる識別子の平均数を表す機能と、任意の1行に含まれる最大数を表す機能があります。図 6 に示す最後の 2 つの機能は、スニペット内で最も頻繁に出現する文字と識別子を検出し、検出された出現数を返します。これらの特徴を組み合わせることで、機械学習アルゴリズムによる分析に適した実数のベクトルへのスニペットからのマッピングが作成されます。
先に、人間の読みやすさの判断は、多くの場合、特徴の複雑な相互作用から生じる可能性があり、さらに、重要な特徴や値を見つけるのが難しい場合があることを示唆しました。その結果、相関関係を確立するための単純な方法では不十分な場合があります。幸いなことに、このような状況のために正確に設計された多くの機械学習アルゴリズムがあります。このようなアルゴリズムは通常、インスタンス[30]上で動作する分類器の形をとっています。我々の目的では、インスタンスとは単一のスニペットから抽出された特徴ベクトルのことです。トレーニング段階では、我々のアノテータからの可読性データに基づいたラベル付きの「正解」と一緒に、分類器にインスタンスのセットを与えます。ラベル付きの正解は、人間のアノテータのデータに基づいて、スニペットを「より読みやすい」と「より読みにくい」に分割するバイナリ判定である。平均スコアが3.14以下のスニペットは、図5の二峰性分布からの自然なカットオフに基づいて「読みにくい」と指定します。残りのスニペットをグループ化し、「より読みやすい」と判断しています。さらに、二値分類を使用することで、より多様な学習アルゴリズムを利用することができます。
学習が完了したら、今まで見たことのないインスタンスに分類器を適用し、それが「より読みやすい」または「より読みにくい」クラスに属する確率の推定値を得ます。これにより、スニペットが「より読みやすい」という確率を可読性のスコアとして使用することができます。我々はWeka [18]機械学習ツールボックスを使用した。
我々は、可読性に関して予測力を持つ特徴のセットに基づいて分類器を構築しました。オーバーフィットの危険性（すなわち、データ量と比較して非常に複雑であるために適合するモデルだけを構築すること）を軽減するために、10倍クロスバリデーション[23]を使用しています（セクション4.2では、データに対するモデルの真の複雑さを理解するのに役立つように設計された主成分分析の結果について説明しています）。10倍クロスバリデーションは、データセットを無作為に10のサブセットに分割し、そのうち9つのサブセットで学習し、最後のサブセットでテストすることからなる。このプロセスを10回繰り返すことで、10個の部分集合のそれぞれがテストデータとして正確に1回使用されます。最後に、ランダムな分割に起因するバイアスを軽減するために、10倍の検証を10回繰り返し、すべての実行にわたって結果を平均化します。

## 4.2 Model Performance
ここでは、コードの局所的なテキスト表面の特徴が、人間の読みやすさの無意識を捉えるのに十分であるという仮説を検証します。この種の実験における2つの関連する成功基準は、リコールと精度です。ここで、リコールとは、注釈者によって「より読みやすい」と判断されたスニペットのうち、モデルによって「より読みやすい」と分類されたスニペットの割合です。精度は、モデルによって「より読みやすい」と分類されたスニペットのうち、注釈者によっても「より読みやすい」と判断された割合である。独立して考えた場合、これらのメトリクスはそれぞれ完全なものにすることができます（例えば、常に "より読みやすい "を返す縮退モデルは完全なリコールを持っています）。そこで、我々は、精度とリコールの調和的平均であるfメジャー統計量[7]を使用して、それらを一緒に重み付けする。これは、ある意味で「より読みやすい」スニペットに対する分類器の精度を反映しています。また、正しく分類されたスニペットの割合を求めることで、分類器の全体的な精度を考慮します。
この実験は，10種類の分類器について行いました．ベースラインを確立するために、ランダムに生成されたスコアラベルを持つスニペットのセットで各分類器を訓練しました。ランダムに推測すると，f値は0.5でベースラインとして機能し，1.0は完全な上限を表します．どの分類器も 0.61 以上の f 値を達成することはできませんでした (ただし、「より読みやすい」と推測することで、実際には 0.67 の f 値を達成することが可能であることに注意してください)。平均的な人間のデータで学習した場合（つまり、ランダムに学習していない場合）、いくつかの分類器は0.8以上に改善されました。これらのモデルには、多層パーセプトロン（ニューラルネットワーク）、ベイズ分類器（特徴の条件付き確率に基づく）、ロジスティック回帰、および投票特徴間隔アプローチ（各特徴によって別々に作られた分類の中で重み付けされた「投票」に基づく）が含まれていました。平均して、これら3つの最良の分類器は、それぞれスニペットの75%から80%の間で正しく分類しました。もし1つの分類器だけが我々の訓練データと一致していたら、我々の可読性という概念の一般性の欠如を示唆していたでしょう。
分類率80%の正解率は絶対的な意味では十分に可能なように見えますが、相対的な意味ではもっと簡単なのかもしれません。ベイズ分類器の出力を連続的に（つまり、バイナリ分類ではなく「より読みやすい」という確率推定値を使用して）、それに対して訓練された平均的な人間のスコアモデルと比較すると、0.71のスピアマン相関が得られます。図7に示されているように、このレベルの一致は、我々の研究の平均的な人間が生成したものよりも16%高いレベルです。図4の3列目は、他の4つの統計量についての結果を示しています。この結果を改善するために、よりエキゾチックな分類器を採用したり、より多くの特徴を調査したりすることはできますが、結果として得られるモデルは、人間のアノテータによって確立された誤差の範囲内にすでに収まっているため、「より良い」モデルになるかどうかは明らかではありません。言い換えれば、非常に現実的な意味で、このメトリックは人間と同じくらい「良い」のです。性能については、このようにして、同値クラスの分類器を選択することができますが、この論文の実験では、実行時の効率性からベイズ分類器を採用しました。

また、各アノテーター経験群（例えば、CS1 年生、CS2 年生）ごとに実験を繰り返した。図8に平均スピアマン相関を示す。左側の暗いバーは、人間とそのグループの平均スコアベクトルの平均一致（すなわち、グループ間の一致）を示している。例えば，CS3 年生と 4 年生は，CS1 年生（0.5 以下の相関）よりも，CS1 年生（0.5 以下の相関）よりも，CS3 年生と 4 年生の方が，お互いの意見が一致することが多い（スピアマン相関は約 0.6）．右側のライトバーは、我々のメトリック（そのグループのアノテータの判断に訓練された）とグループ内の全アノテータの平均値との間の相関を示しています。3つの興味深い観察があります。第一に、すべてのグループにおいて、我々の自動指標は、人間の平均値と人間の平均値が一致するよりも、より密接に一致しています。第二に、大学院生を除いて、経験があるほど一致率が高くなるという緩やかな傾向が見られます。卒業生に関する差は、大学院生の背景がより多様であること、彼らの意見がより洗練されていること、またはその他の外的要因を反映しているのではないかと考えられます。第三に、我々のモデルの性能は、4つのグループすべてにおいて非常に一貫しており、ある程度、学習データのソースにロバストであることを示唆しています。
我々は、一度に1つの特徴のみを使用して全注釈者分析を再実行することで、どの特徴が最も事前に決定力を持っているかを調査しました。分類器の性能の相対的な大きさは、各特徴の比較重要度を示しています。図9は、大きさを0と1の間で正規化した分析結果を示しています。

例えば、「平均的な行の長さ」や「1行あたりの平均的な識別子数」のような要素は、読みやすさにとって非常に重要であることがわかります。逆に、「平均的な識別子の長さ」は、それ自体はあまり予測的な要素ではありませんが、if構文、ループ、比較演算子も予測的な要素ではありません。セクション6では、この結果から考えられるいくつかの意味合いについての議論が含まれています。これらの図のいくつかは、自動化された複雑度メトリクス[27]で使用されているものと似ています: セクション5.2では、可読性と複雑度の重なりを調査しています。
我々は、このシングルトン特徴分析をリーヴよりも好んで用いている。
ワンアウト分析（分類器の性能の低下に基づいて特徴のパワーを判断する）は，特徴の重なりが大きいために誤導する可能性があります．これは、2つ以上の特徴が異なっているにもかかわらず、根本的に同じ現象を捉えている場合に起こります。簡単な例として、2つの単語の間にちょうど1つの空間がある場合、単語をカウントする特徴と空間をカウントする特徴は本質的に同じ情報を捉え、どちらか一方を残しても精度が低下することはほとんどありません。主成分分析（PCA）は、総変動の95%が8つの主成分で説明できることを示しており、特徴の重複が有意であることを示唆しています。最初の8つの主成分によって説明された累積分散の合計は、以下のようになります{41%, 60%, 74%, 81%, 87%, 91%, 93%, 95%}。

# 5 CORRELATING READABILITY WITH SOFTWARE QUALITY
前節では、人間の判断を模倣した可読性の自動モデルを構築しました。このモデルは、プログラムの可読性を評価するツールに実装しました。このセクションでは、このツールを使用して、可読性（我々のモデルによって捕捉された）がソフトウェア品質の外部の従来の測定基準と相関するという仮説を検証します。具体的には、まず、一般的な静的バグ発見ツールであるFindBugsと可読性との間に相関関係があるかどうかを検証します。次に、いくつかの大規模なオープンソースプロジェクトのバージョン間で、コードの変更と同様の相関関係があるかどうかをテストします。第三に、バグが発見され修正されたことを示すバージョン管理ログメッセージについても同様のテストを行います。次に、可読性がサイクロマチックの複雑さ[27]と相関しているかどうかを調べ、可読性の概念が固有の複雑さから大きく独立しているという先に主張したことを検証します。最後に、ソフトウェア・プロジェクト全体におけるコードの可読性の傾向を調べます。
ベンチマークとして採用したオープンソースのJavaプログラムのセットを図10に示します。これらのプログラムは、相対的に人気があること、開発の成熟度とアプリケーション・ドメインの点で多様性があること、オープンソース・ソフトウェアのリポジトリであるSourceForgeから複数のバージョンが入手可能であることなどの理由から選択されました。成熟度は自己申告であり、SourceForge では 1-planning、2-pre-α、3-alpha、4-β、5-production/stable、6-mature、7-inactive に分類されています。プロジェクトによっては、異なる成熟度レベルで複数のリリースを提示している場合があることに注意してください。
可読性ツールの実行（機能の判別と可読性の判定を含む）は、非常に迅速に行われました。例えば、2GHzのプロセッサとディスクを搭載したマシンで、最大150MBytes/secの転送速度を持つディスクで、SoapUIの98K行のコードを処理するのに16秒もかかりませんでした（1秒あたり約6KのLOC）。

## 5.1 Readability Correlations
最初の実験では、FindBugsによって検出された欠陥と、関数レベルでの可読性指標との間に相関関係があるかどうかをテストしました。まず、ベンチマーク上でFindBugsを実行し、欠陥レポートを記録しました。次に、すべての関数を抽出し、報告された欠陥を1つ以上含む関数と含まない関数の2つのセットに分割しました。報告された欠陥の数が異なるプログラム間での偏りを避けるため、関数セットのサイズを正規化しました。次に、既に学習済みのクラスシファイアを関数セット上で実行し、"readableでない "という分類器の判定に対する "バグが含まれている "のf値を記録しました。この実験の目的は、我々のモデルがコード品質の外部概念と相関する範囲を調査することです。
我々の2つ目の実験では、「コード解約」と可読性との間に同様の相関関係があるかどうかをテストしています。バージョン間の変更は、コード品質のもう一つの重要な側面を捉えています。この実験では、最初の実験と同じセットアップを使用しましたが、可読性を使用して、プログラムの2つの連続したリリースの間にどの関数が変更されるかを予測しました。この実験では、「連続リリース」とは、最新の安定版の2つのバージョンを意味します。言い換えれば、"バグが含まれている "のではなく、"すぐに変更されるだろう "という予測を試みています。我々は、テキストが全く同じではない場合には、空白の変更も含めて、関数が変更されたとみなします。空白は通常プログラム研究では無視されますが、我々は特に可読性に焦点を当てているので、関連性があると考えています。
最初の実験では、バグファインダからの出力を調べていますが、そのような出力はコードの真の欠陥とは言えないかもしれません。3つ目の実験では、開発者が実際に指摘した欠陥と可読性との関係を調査しています。コードベースの変更を管理するためにバージョン管理リポジトリを使用することは、ソフトウェアエンジニアリングの標準的な慣行となっています。このようなシステムでは、変更が行われると、開発者は通常、変更を記述したログメッセージを含みます。このようなログメッセージは、ソフトウェア機能の追加、最適化、または他の潜在的な変更の数を記述することができます。場合によっては、ログメッセージに「バグ」への参照が含まれていることもあります - 多くの場合、プロジェクトのバグデータベースから関連するバグ追跡番号を使用しますが、常にではありません。この3つ目の実験では、バグに言及したログメッセージで関数が変更されたかどうかを予測するために、可読性のメトリックを使用しています。
15のベンチマークのうち12のベンチマークは、少なくとも500件以上のレビジョンを持つ一般にアクセス可能なバージョン管理システムを特徴としています(ほとんどのベンチマークは数千件)。各プログラムの最新バージョンについて、コードの各行について、その行を変更した最後のリビジョンを決定します（例えば、これは一般的な cvs の非難ツールに似ています）。評価対象を各ベンチマークの最新の1000リビジョンに限定し、合計111,670個のバグ報告を受けた5087個の関数を見つけました。次に，ログメッセージに「バグ」という単語がないかどうかを調べ，不具合に対処するために変更が加えられたかどうかを判断します．すべての関数を、バグに対処するために少なくとも1行以上の変更が最後に行われた関数と、バグに対処するために1行も変更が行われていない関数の2つのセットに分割します。
図11は、これらの3つの要素の結果をまとめたものです。FindBugs相関のベンチマークにおける平均f値は0.62 (精度=0.90, リコール=0.48)、バージョン変更の場合は0.63 (精度=0.89, リコール=0.49)、適用可能な12のベンチマークにおけるバグ修正を示すログメッセージの平均f値は0.65 (精度=0.92, リコール=0.51)でした。我々の目標は、FindBugsやその他の欠陥報告のソースとの完全な相関関係ではないことに注意が必要です。その代わりに、我々の可読性指標は一般的に有用であり、ソフトウェア品質の複数の概念と相関があることを主張しています。可読性の低いコードは、後で開発者がバグ修正のために変更する可能性が非常に高くなります。
2つ目の重要な考慮事項は、その差の大きさです。我々は、分類器の確率（連続出力と離散分類の比較）が可読性の評価に有用であると主張しています。図12は、このデータを比率の形で示しています。これは、分類器がFindBugsの欠陥に対して陽性の関数、またはこれらの特徴を持たない関数に対するバージョン変更に対して符号を付けた平均確率です。多くのプロジェクトで比率が1を超える（つまり100%を超える）ということは、これらの特徴を持つ関数は、これらの特徴を持たない関数に比べて可読性スコアが低い傾向にあることを示しています。例えば、jMencodeとSoapUIプロジェクトでは、我々のメトリックで可読性が低いと判断された関数は、FindBugsの欠陥レポートを含む可能性が劇的に高く、JasperReportsプロジェクトでは、可読性が低いメソッドは次のバージョンで変更される可能性が非常に高いことがわかりました。
簡単な注意点として、可読性分布の標準偏差は意図的に報告しないようにしています。私たちのメトリックがベースとしている基礎となるスコア分布（図5を参照）と、私たちのツール自体の出力は、どちらもバイモーダルです。実際、ベンチマーク上のツールの出力は、正規分布よりもバスタブ分布または一様ランダム分布に近くなります。その結果、標準偏差の意味合いについての標準的な推論は適用されません。しかし、このような分布の平均は、分布の下半分と上半分のメソッドの比率をよく特徴づけます(すなわち、「より読みやすい」メソッドと「より読みやすい」メソッドを比較して、「読みにくい」メソッドの母集団を特徴づけます)。
これら3つの外部品質指標のそれぞれについて、我々のツールはかなりの相関関係を示していることがわかりました。当社の可読性メトリクスに基づいて予測すると、f値が0.8を超える場合もあります。繰り返しになりますが、私たちの目標は、バージョン変更やコード解約との完全な相関関係ではありません。これらの中程度の相関関係は、我々のモデルで記述されているコードの可読性と、欠陥や今後のコード変更との間には実質的な関連性が存在するという仮説を支持しています。

## 5.2 Readability and Complexity
この論文では、可読性をコード理解性の「偶発的な」構成要素と定義しました。これは、コードを書く際の成果物であり、コードが解決しようとしている問題の複雑さとは密接に関係していないという考えに言及しています。我々の短いスニペットの選択方針は、複雑さを覆い隠し、可読性とは切り離すのに役立ちます。また、我々は、コードの選択範囲の長さに対して不可知であるように設計された表面的な特徴のセットを選択しました。それにもかかわらず、いくつかの特徴はまだある程度の複雑さを捉えている可能性があります。ここで、可読性と複雑さは密接に関連していないという仮説を検証します。
コードの複雑さの自動モデルの具体的な例として、McCabeのCyclomatic測定値[27]を使用します。我々は、各ベンチマークにおいて、各手法のCyclomatic複雑さと可読性を測定しました。両方の量は序数であるため（以前の3つの実験では2進数ではなく）、それらの間のピアソンのrを計算しました。また、基準線として使用するために、サイクロマチック複雑度とメソッドの長さの相関も計算しました。図13は、可読性がこの伝統的な複雑さの概念と密接に関連していないことを示しています。一方、メソッドの長さは、複雑さとの関連性が非常に強いことがわかります。このように、我々の考える可読性の概念は複雑さと直交するものではないが、大部分は別個の現象をモデル化していると結論づけています。

## 5.3 Software Lifecycle
我々の可読性指標と外部要因との関係をさらに調べるために、長期にわたる変化を調査しました。プロジェクトの可読性に観察される傾向は、プロジェクトの欠陥にも同様の傾向が現れるという仮説を立てました。図14は、可読性と欠陥率がプロジェクトの寿命期間中にどのように変化するかを縦断的に調査したものです。この図を作成するために、バージョン履歴が豊富ないくつかのプロジェクトを選択し、それぞれのプロジェクトに含まれるすべての機能について平均可読性レベルを計算しました。jFreeChart での欠陥密度を除いて、各プロジェクトは統計的有意水準（p値）で 0.05 以上の線形関係を示しています。
オープンソースのプロジェクトでは、新しくリリースされたバージョンは、常に前のバージョンよりも安定しているとは限らないことに注意してください。プロジェクトでは、大規模なオーバーホールが行われたり、追加のクロスカッティング機能が追加されたりすることがよくあります。最近、「Java 5.0 の新機能 (アノテーション、静的インポート......) に依存した全く異なる API ....... [20]」を採用した jUnit を考えてみましょう。
図14の一番右のグラフは、複数のプロジェクトのリリースにおける FindBugs-報告された欠陥密度をプロットしたものです。HibernateやSoapUIなどのほとんどのプロジェクトでは、読みやすさのプロファイルが非常にフラットになっています。これらのプロジェクトでも、同様にフラットな欠陥密度が見られます。一方、jUnit プロジェクトでは、リリース 5 から 0 (新しい API が導入されたため) までの間に可読性が急激に低下し、それに対応してリリース 5 から 0 までの間に欠陥密度が増加しています。 JUnit の場合、テストした最初のバージョンでは 58.9% の関数の可読性が 0.5 以下であり、最新のバージョンでは 71.4% (12.5% の増加) であることがわかります。残りの 4 つのシステムのうち、最も大きな変化があったのは SoapUI です。0.5以下では44.3%から48.1%(3.8%の増加)となりました。このケーススタディでは、我々の可読性指標は、異なるプロジェクト間、および同じプロジェクトの異なるリリース間のソフトウェア品質指標と強く相関しています。
さらに、成熟度および安定性に対する可読性を測定するために、1 つの研究を実施しました。図 15 は、開発者が自己申告したプロジェクトの成熟度に対するプロジェクトの可読性をプロットしたものです。このデータは、ノイジーではありますが、統計的には有意な上昇傾向を示しています（ピアソンの r = 0.80、p = 0.00031）。例えば、すべての「6-成熟した」プロジェクトは、すべての「3-α」プロジェクトよりも読みやすくなっています。

# 6 Discussion
本研究では、局所的なコードの特徴と可読性の関係について、かなりの量の経験的なデータが含まれています。この情報は、コードの書き方や評価の仕方、プログラミング言語の設計に影響を与える可能性があると考えています。しかし、このデータは我々のアノテータに真に関連するものであり、可読性に関する包括的な普遍的なモデルを表すものと解釈すべきではないことに注意してください。さらに、記述的モデルの性質上、コーディング方法を直接規定するのには適していないかもしれません。しかし、コードの可読性について、より慎重に検討されるべき側面を特定するのには有用であると考えています。
まず、識別子名の長さは可読性にほとんど影響を与えないことがわかりました（相対的な予測力は0％）。この観察は、「1文字の識別子は. 保守作業をはるかに困難にする」という一般的な信念を裏付けるものではありません [22]。この観察は、長くて説明的な識別子名とほとんど省略形がないことが多い「自己文書化されたコード」に向けた顕著な動きに貢献したと思われます。この動きはJavaコミュニティに特に影響を与えた。さらに、タイピング情報を識別子名にエンコードしようとする 「ハンガリー語」表記法のような命名規則は、慎重に検討されるべきである [36]。我々の研究では、平均的な識別子の長さの予測力はほぼゼロであったが、最大の識別子の長さの方が負の予測因子として有用であった。符号化された型情報やその他の変数の命名規則を検出する機能は含まれていませんでしたが、追加の情報を伝えずに識別子の長さが長くなるようなパラダイムは、可読性に悪影響を与える可能性があります。
識別子とは異なり、コメントは非常に直接的に意図を伝える方法です。コメントの存在によって可読性が劇的に向上することを期待するかもしれません。しかし、コメントは注釈者の可読性の概念と中程度の相関関係しかないことがわかりました（33%の相対力）。1つの結論として、コメントは可読性を高めることができますが、コメントは一般的に、最初は可読性の低いコード・セグメントで使用されます。正味の効果は、コメントが必ずしも可読性の高低を示すものではないということです。
1行あたりの識別子の数と文字数は、可読性の指標に強い影響を与えます（それぞれ100％と96％の相対的なパワー）。長い文章が理解しにくいのと同じように、長いコード行も理解しにくいようです。この結果は、プログラマーは文を複数の行に分割しても、行を短く保つべきだという従来の常識を裏付けています。
プログラミング言語を設計する際、可読性は重要な関心事です。言語は、様々な設計や言語機能がこの指標に与える影響を考慮して、可読性の改善を強制的に、あるいは奨励するように設計されているかもしれません。例えば、Pythonは理解を助けるために特定のインデントスキームを強制しています[29], [40]。我々の実験では、1行あたりの文字数の重要性は、言語がスイッチ文や前後インクリメントのような短い行を促進する構造を使用することを支持すべきであることを示唆しています。我々のデータは、プログラムがより少ない新しい識別子で書かれることを意味するならば、言語は追加のキーワードを追加すべきであることを示唆している。
我々の可読性のモデルは、規範的・規定的ではなく、記述的であることに注目すべきである。つまり、既存のソフトウェアの人間の可読性判断を予測するために使用することはできますが、可読性を向上させるための変更を規定するために直接介入することはできません。例えば、「平均空行数」は、高い可読性と正の相関を持つ強力な機能ですが、既存のコードのすべての行の後に5行の空行を挿入するだけでは、そのコードの可読性に対する人間の判断を改善する必要はありません。同様に、長い識別子は我々のモデルでは可読性スコアの低下に寄与しますが、すべての識別子をランダムな2文字の配列に置き換えても、その効果は期待できません。このような関係を分離して、モデルで指定された変更をコードに適用してから、2回目の人間による研究で実際の可読性の変化を評価することで、モデルを改良することができるかもしれません。ソフトウェアの可読性に関するこのような規範的なモデルを学習することは、今後の課題です。
最後に、言語設計者が新しい言語機能を検討する際に、そのような機能が可読性に与える影響の研究を行うことは有用かもしれません。本論文で紹介する技術は、このような実験を実施するためのフレームワークを提供します。

# 7 THREATS TO VALIDITY
妥当性に対する潜在的な脅威の1つは、本研究の参加者のプールに関係しています。特に、本研究の参加者は主にコンピュータサイエンスの入門・中級コースからの参加者であり、産業界の実務家と比較してコードを読んだり書いたりする経験が少ないことを示唆しています。さらに、同じ教育機関で統一的な指導を受けた結果、特定のコーディング手法やイディオムにある程度のバイアスがかかっている可能性があります。
我々のモデルは、バージニア大学のコンピュータサイエンスの学生の意見のみに基づいて構築されているため、彼らによると読みやすさのモデルに過ぎません。しかし、我々が提示した指標は、ソフトウェアーの品質を表す3つの外部指標と有意な相関関係を示しています。さらに、本研究では、学歴や専門的なバックグラウンドが大きく異なる大学院生であっても、お互いに、そして我々の尺度と強い一致を示していることを示しています。このことは、この種のアノテータのバイアスが小さい可能性を示唆していますが、本論文ではこれを直接調査していません。最後に、可読性のための最終的なメトリックを提示するのではなく、任意の母集団からさらなるメトリックを構築するための方法論と結合した初期メトリックを提示します。
また、有効性に対する潜在的な脅威として、スニペットをスコアリングするための方法論についても検討しています。制約のあるものではなく、直観的な可読性の概念を捉えるために、参加者に可読性をどのように判断するかについての具体的なガイダンスは提供しませんでした。可読性の正確な定義（考慮すべき要素のリストなど）を含む同様の研究では、アノテータ間の一致がはるかに大きくなる可能性があります。このような状況下で、我々のモデリング技術がどのように機能するかは不明です。同様に、練習と疲労の両方の要因が一致度に影響を与えたり、モデルにバイアスをかけたりする可能性があります。しかし、スニペットセット全体のスコアデータの分散には有意な傾向は見られません（スコアの分散に対する線形回帰の傾きは0.000、R-2乗値は0.001であり、練習の影響は最小限であることを示唆しています）。

# 8 Future works
この論文で紹介した技術は、今後の可読性実験、特に非常に多くの判定を正確な可読性モデルに統一するという点で、優れたプラットフォームを提供してくれるはずです。
コードの可読性を規定する要因については、アノテータ間でかなりの合意が得られていることがわかりましたが、各アノテータは個人的な好みを持っており、関連する要因の重み付けが多少異なることが予想されます。時間をかけて適応させたパーソナライズされたモデルと組織レベルのモデルが、コードの可読性を特徴づけるのに有効かどうかを調査することは興味深いことです。さらに、可読性の要因は、アプリケーションのドメインに基づいて大きく異なる可能性があります。この変動の程度を判断し、特殊なモデルが有用かどうかを判断するためには、さらなる研究が必要です。
もう一つの改善の可能性としては、我々の局所的なコード可読性の概念を、より広範な特徴を含むように拡張することが考えられます。我々の特徴のほとんどは、1行あたりの平均値や最大値として計算されていますが、ifブロック内の単純な文の数など、複合文のサイズを考慮することは有用かもしれません。この研究では、複雑さではなく可読性を確実に把握するために、このような特徴を意図的に避けました。しかし、実際には、このように懸念事項を分離することは説得力に欠ける可能性があります。
可読性測定ツールには、プログラマのアクセスという点で独自の課題があります。私たちは、自然言語の可読性測定基準がワードプロセッサに組み込まれているのと同じように、そのようなツールをEclipseなどのIDEに統合することを提案します。作者には読めるように見えるソフトウェアでも、他の人には理解するのが非常に難しい場合があります [16]。このようなシステムは、構文エラーの識別に似た方法で、そのようなインスタンスが発生したときにプログラマーに警告することができます。
最後に、従来の可読性のメトリクスに沿って、少数の特徴について単純な式を用いて我々のメトリクスを表現することは価値があると思います（セクション4.2のPCAは、これが可能である可能性を示唆しています）。本当に必要な特徴と予測可能な特徴のみを使用することで、多くの開発プロセスに容易に適合させることができます。さらに、係数の数を少なくすることで、特定の環境での可読性をよりよく記述するため、またはより特定の懸念事項を満たすために、可読性メトリックをパラメータ化または修正することができます。

# 9 Conclusion
本論文では、人間のアノテータの判断に基づいてコードの可読性をモデル化する手法を提示した。120名のコンピュータサイエンスの学生を対象とした研究では、比較的単純な低レベルのコード特徴のセットを考慮するだけで、これらのアノテータと同じくらい一致するメトリックを作成できることを示しました。さらに、このメトリクスによって記述される可読性は、欠陥、コード解約、自己報告された安定性などのソフトウェア品質のより一般的なメトリクスと有意なレベルの相関を持つことがわかりました。さらに、可読性に影響を与える要因を考慮することが、ソフトウェア品質のこの重要な次元に関して、プログラミング言語の設計とエンジニアリングの実践を改善する可能性があることを議論しました。最後に、本稿で述べたメトリックは、可読性の最終的または普遍的なモデルとして意図されたものではないことに注意することが重要です。